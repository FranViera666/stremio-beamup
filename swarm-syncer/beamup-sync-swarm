#!/usr/bin/env node

const fs = require('fs')
const http = require('http')
const httpGet = args => new Promise((resolve, reject) => http.get(args, resolve).on('error', reject))

const START_PORT = 8000
const REGISTRY_URL = 'http://127.0.0.1:5000'

const HEADER = `version: '3.7'
services:`

// @TODO: assigning a random port may not be needed, just use the docker overlay network to reach the container (use it's IP)
// @TODO: syslog for centralized log collection
// By default,the restart policy is "any" (it will always restart)
// @TODO restart max attempts?
// @TODO hardware limits
const APP_TMPL = (appName, image, port) => `   ${appName}:
        image: ${image}
        deploy:
          mode: global
          resources:
            limits:
              cpus: '1'
              memory: 1024m
          restart_policy:
              max_attempts: 20
              window: 1h
        environment:
          - PORT=${port}
        command: /start web
        ports:
          - '${port}:${port}'`

const APP_NGINX_TMPL = (appName, port) => `proxy_cache_path /var/lib/nginx/cache_${appName} levels=1:2 keys_zone=${appName}_cache:10m max_size=1g inactive=600m use_temp_path=off;
upstream ${appName} {
        server 127.0.0.1:${port};
        keepalive 300;
}

server {
        server_name ~^${appName}.;
        access_log     /var/log/nginx/nginx.vhost.access.log;
        error_log      /var/log/nginx/nginx.vhost.error.log;
        #listen     443;
        #ssl        on;
        #ssl_certificate  /etc/nginx/cert.pem;
        #ssl_certificate_key /etc/nginx/cert.key;
        listen 80;
        location / {
                proxy_pass http://${appName};
                proxy_http_version 1.1;
                proxy_set_header Connection "";
                proxy_cache ${appName}_cache;
                proxy_cache_use_stale error timeout http_500 http_502 http_503 http_504 updating;
                proxy_cache_background_update on;
                proxy_cache_lock on;
                proxy_hide_header X-Powered-By;
                proxy_buffering on;
                proxy_cache_valid 200 302 2h;
                add_header X-Cache-Status $upstream_cache_status;
        }
}

`

async function getJSON(opts) {
	const res = await httpGet(opts)
	if (res.statusCode !== 200) throw new Error(`returned status ${res.status}`)
	res.setEncoding('utf8')
	return new Promise((resolve, reject) => {
		let body = ''
		res.on('data', d => body += d)
		res.on('error', reject)
		res.on('end', () => resolve(JSON.parse(body)))
	})

}

async function getImages() {
	return await getJSON(`${REGISTRY_URL}/v2/_catalog`)
}

async function getPortMapping() {
	const services = await getJSON({ socketPath: '/var/run/docker.sock', path: '/services' })
	let ports = {}
	services.forEach(service => {
		const { TargetPort, PublishedPort } = service.Endpoint.Ports[0]
		// @TODO: better imageName?
		const imageName = service.Spec.Labels['com.docker.stack.image']
		if (TargetPort === PublishedPort) ports[imageName] = TargetPort
	})
	return ports
}

async function getConfigs() {
	const [{ repositories }, portMapping] = await Promise.all([getImages(), getPortMapping()])
	let startPort = Math.max.apply(null, Object.values(portMapping)) || START_PORT
	const apps = repositories.map(imageName => {
		const name = imageName.split('/').pop()
		const fullImageName = `localhost:5000/${imageName}:latest`
		const port = portMapping[imageName] || portMapping[fullImageName] || ++startPort
		return { name, fullImageName, port }
	})
	const swarmCfgs = apps.map(app => APP_TMPL(app.name, app.fullImageName, app.port))
	const nginxCfgs = apps.map(app => APP_NGINX_TMPL(app.name, app.port))
	return {
		swarm: [HEADER].concat(swarmCfgs).join('\n'),
		nginx: nginxCfgs.join('\n'),
	}
}

const swarmCfg = process.argv[2]
const nginxCfg = process.argv[3]
if (!(swarmCfg && swarmCfg.endsWith('.yaml') && nginxCfg && nginxCfg.endsWith('.conf'))) {
	console.log('usage: beamup-sync-swarm <path to swarm yaml> <path to nginx config>')
	process.exit(1)
}
getConfigs().then(cfgs => {
	fs.writeFileSync(swarmCfg, cfgs.swarm)
	fs.writeFileSync(nginxCfg, cfgs.nginx)
})
